# -*- coding: utf-8 -*-
"""utilsss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/168zBXgcGzqJ3V-69ZjjE_ndpLsFeTaKp

# Utils
## Import libraries
"""

import cv2 as cv
import tensorflow as tf
import tensorflow.keras as tfk
from tensorflow.keras import utils, layers, losses, optimizers, models, Sequential, Model
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
import os
from pathlib import Path
from collections import Counter

"""## Functions"""

def decode_batch_predictions(pred):
    '''
        Description: is a utility function to decode the output of the inference network
        *Args:
        pred: output of inference network(prediction)

        *Returns:
        output_text: List of text: Iterate over the results(of ctc_decode) and get back the text and append them

    '''
    input_len = np.ones(pred.shape[0]) * pred.shape[1]
    results = tfk.backend.ctc_decode(pred, input_length=input_len, greedy=True)[0][0][:, :max_length]
    '''
        (tfk.backend.ctc_decode)
        *Args:
        y_pred: tensor (samples, time_steps, num_categories) containing the prediction, or output of the softmax.
        input_length: tensor (samples, ) containing the sequence length for each batch item in y_pred.
        greedy: perform much faster best-path search if true. This does not use a dictionary.
        beam_width: if greedy is false: a beam search decoder will be used with a beam of this width.
        top_paths: if greedy is false, how many of the most probable paths will be returned.


        *Returns:
        Tuple: List: if greedy is true(like here), returns a list of one element that contains the decoded sequence.
        Important: blank labels are returned as -1.
        Tensor (top_paths, ) that contains the log probability of each decoded sequence.
    '''
    # Iterate over the results and get back the text
    output_text = []
    for res in results:
        res = tf.strings.reduce_join(num_to_char(res)).numpy().decode("utf-8")
        output_text.append(res)
    return output_text